%!TEX root = ../ff.tex

\begin{figure}[t]
\twoCols{0.22}{0.22}
{
\vspace{-1.0em} % TODO: temporary fix
\begin{pcvstack}[left]
\procedure{Game $\gPRF{\FF,\advA}(\secParam)$}
  {
    b\getsr\bits\\
	\FKey\getsr\Kg{\FF}(\secIn)\\
	b'\getsr\advA^{\RoRO}(\secIn)\\
	\pcreturn (b'=b)
  }
\pcvspace
\procedure{Oracle $\RoRO(x)$}
  {
     \pcif T[x] = \perp \pcthen \\
	 \pcind T[x] \getsr \Rng{\FF}(\secParam,\FKey) \\
     y_1\gets\Ev{\FF}(\secIn,\FKey,x)\\
     y_0\gets T[x]\\
	 \pcreturn y_b
  }
\end{pcvstack}  
}
{
\vspace{-1.0em} % TODO: temporary fix
\begin{pcvstack}[left]
\procedure{Game $\gPPRF{\FF,\advA}(\secParam)$}
  {
    b\getsr\bits\\
	\FKey\getsr\Kg{\FF}(\secIn)\\
	b'\getsr\advA^{\FnO}(\secIn)\\
	\pcreturn (b'=b)
  }
\pcvspace
\procedure{Oracle $\FnO(x^*)$}
  {
     \PFKey\getsr\PKg{\FF}(\secIn,\FKey,x^*)\\
     y_1\gets\Ev{\FF}(\secIn,\FKey,x^*)\\
     y_0\getsr\Rng{\FF}(\secParam,\FKey)\\
	 \pcreturn (\PFKey, y_b)
  }
\end{pcvstack}  
}
\figvspace
\caption{Games defining
           pseudorandomness of function family $\FF$,
		   and pseudorandomness of punctured function family $\FF$.}
\label{fig-ff-prf}
\label{fig-ff-pprf}
\hrulefill
\end{figure}

\heading{Pseudorandom functions.}
...

\heading{Punctured pseudorandom functions.}
...

\iffalse
\heading{Pseudorandom Function}
We present GGM's definition of pseudorandom function security~\cite{GolGolMic86}. The formalization is based on game $\gPRF{\FF}(\advA)$ of \figref{fig-ff-prf}, associated to family of functions $\FF$ and adversary $\advA$. The game initially samples a random challenge bit $b$, with $b=1$ indicating it is in ``real'' mode and $b=0$ that it is in ``random" mode. As per our conventions noted in \secref{sec-defs},  the sets $V,W$ are assumed initialized to the empty set, and the integer $v$ is assumed initialized to $0$. Now the adversary $\advA$ also has access to an evaluation oracle $\RoRO$ that takes an input $x$. The oracle either returns a uniformly random element from $\Rng{\FF}$ (for $b=0$), or an evaluation under $\Ev{\FF}$ using the key (for $b=1$). The oracle checks that $\advA$ does not an input $x$. As a last step, the adversary outputs a bit $b'$ that can be viewed as a guess for $b$.  The advantage of adversary $\advA$ in breaking the mu-ind security of   $\FF$ is defined as $\prfAdv{\FF}{\advA} = 2\Pr[\gPRF{\FF}(\advA)]- 1$.


Hmmm...PRFs also have weirdness if uniform sampling from $\Rng{\FF}$ cannot be done efficiently/if $\setsize{\Rng{\FF}}=1$ .
\fi

